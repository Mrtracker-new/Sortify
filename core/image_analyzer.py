import os
import logging
import math
import hashlib
import datetime
from pathlib import Path
from collections import Counter

# Try to import PIL, but make it optional
try:
    from PIL import Image, ExifTags, ImageStat, ImageDraw, ImageFilter
    PIL_AVAILABLE = True
except ImportError:
    logging.warning("PIL module not found. Enhanced image analysis will be limited.")
    PIL_AVAILABLE = False

# Try to import OpenCV for advanced image analysis
try:
    import cv2
    import numpy as np
    OPENCV_AVAILABLE = True
except ImportError:
    logging.warning("OpenCV module not found. Advanced image analysis will be limited.")
    OPENCV_AVAILABLE = False

class ImageAnalyzer:
    """Enhanced image analyzer with advanced categorization capabilities"""
    def __init__(self):
        self.supported_formats = {
            '.jpg', '.jpeg', '.png', '.gif', '.bmp', '.tiff', '.tif', '.webp', '.svg', '.svgz',
            '.heic', '.heif', '.raw', '.cr2', '.nef', '.arw', '.dng', '.psd', '.ai', '.eps'
        }
        self.photo_formats = {'.jpg', '.jpeg', '.heic', '.heif', '.raw', '.cr2', '.nef', '.arw', '.dng'}
        self.vector_formats = {'.svg', '.svgz', '.ai', '.eps'}
        self.design_formats = {'.psd', '.ai', '.eps'}
        self.cache = {}
        self.cache_size = 100
        
        # Format categories for categorization
        self.format_categories = {
            'photos': self.photo_formats,
            'vectors': self.vector_formats,
            'designs': self.design_formats,
            'screenshots': {'.png'},
            'gifs': {'.gif'},
            'webimages': {'.webp'}
        }
        
        # AI image source patterns
        self.ai_image_sources = {
            'chatgpt': ['chatgpt', 'gpt', 'openai', 'dall-e', 'dalle', 'dall e'],
            'midjourney': ['midjourney', 'mj'],
            'stable_diffusion': ['stable diffusion', 'stablediffusion', 'sd'],
            'bing': ['bing ai', 'bing image', 'bing creator'],
            'bard': ['bard', 'google bard', 'google ai'],
            'claude': ['claude', 'anthropic'],
            'other_ai': ['ai generated', 'ai created', 'ai image', 'generated by ai']
        }
    
    def analyze_image(self, image_path):
        """Analyze an image file and return comprehensive metadata
        
        Args:
            image_path: Path to the image file
            
        Returns:
            dict: Dictionary containing image metadata including dimensions, 
                  creation date, and EXIF data when available
        """
        image_path = Path(image_path)
        
        # Check if file exists
        if not image_path.exists():
            logging.warning(f"Image file does not exist: {image_path}")
            return {
                'filename': image_path.name,
                'extension': image_path.suffix.lower(),
                'exists': False,
                'category': 'Unknown'
            }
        
        # Basic metadata available for all image files
        metadata = {
            'filename': image_path.name,
            'extension': image_path.suffix.lower(),
            'size': os.path.getsize(image_path),
            'size_mb': round(os.path.getsize(image_path) / (1024 * 1024), 2),
            'category': self._determine_category(image_path),
            'created': self._get_creation_time(image_path),
            'modified': self._get_modification_time(image_path),
            'exists': True
        }
        
        # Check if image is from an AI source
        ai_source = self._detect_ai_source(image_path)
        if ai_source:
            metadata['ai_source'] = ai_source
            metadata['is_ai_generated'] = True
        else:
            metadata['is_ai_generated'] = False
        
        # Enhanced metadata using PIL if available
        if PIL_AVAILABLE:
            try:
                with Image.open(image_path) as img:
                    # Add image dimensions
                    metadata['width'], metadata['height'] = img.size
                    metadata['aspect_ratio'] = round(img.size[0] / img.size[1], 2) if img.size[1] > 0 else 0
                    metadata['mode'] = img.mode  # Color mode (RGB, CMYK, etc.)
                    
                    # Extract EXIF data if available
                    exif_data = {}
                    if hasattr(img, '_getexif') and img._getexif():
                        exif = {ExifTags.TAGS.get(k, k): v for k, v in img._getexif().items() if k in ExifTags.TAGS}
                        
                        # Extract useful EXIF information
                        if 'DateTimeOriginal' in exif:
                            exif_data['date_taken'] = exif['DateTimeOriginal']
                        if 'Make' in exif:
                            exif_data['camera_make'] = exif['Make']
                        if 'Model' in exif:
                            exif_data['camera_model'] = exif['Model']
                        if 'GPSInfo' in exif:
                            exif_data['has_gps'] = True
                        
                        metadata['exif'] = exif_data
                    
                    # Determine if image is likely a screenshot based on properties
                    metadata['is_screenshot'] = self._is_likely_screenshot(img, metadata)
                    
                    # Determine if image is likely a document scan
                    metadata['is_document'] = self._is_likely_document(img, metadata)
                    
                    logging.debug(f"Enhanced metadata extracted for {image_path}")
            except Exception as e:
                logging.debug(f"Could not extract enhanced metadata from {image_path}: {e}")
        
        return metadata
    
    def _determine_category(self, image_path):
        """Determine the category of an image based on its extension and other properties
        
        Args:
            image_path: Path to the image file
            
        Returns:
            str: Category name with proper capitalization
        """
        # Check for AI-generated images first
        ai_source = self._detect_ai_source(image_path)
        if ai_source:
            return f'AI/{ai_source.capitalize()}'
            
        # Check for social media files
        if self.is_whatsapp_media(image_path):
            return 'WhatsApp'
        elif self.is_telegram_media(image_path):
            return 'Telegram'
        elif self.is_instagram_media(image_path):
            return 'Instagram'
        elif self.is_facebook_media(image_path):
            return 'Facebook'
        elif self.is_youtube_media(image_path):
            return 'YouTube'
            
        extension = image_path.suffix.lower()
        
        # Check each category for matching extension
        for category, extensions in self.format_categories.items():
            if extension in extensions:
                return category.capitalize()
        
        # Default category
        return 'Other'
    
    def _detect_ai_source(self, image_path):
        """Detect if an image is from an AI source based on filename patterns
        
        Args:
            image_path: Path to the image file
            
        Returns:
            str: AI source name or None if not detected
        """
        file_name = Path(image_path).name.lower()
        
        # Check for AI source patterns in filename
        for source, patterns in self.ai_image_sources.items():
            if any(pattern in file_name for pattern in patterns):
                return source
                
        # Check for common AI image dimensions and aspect ratios
        if PIL_AVAILABLE:
            try:
                with Image.open(image_path) as img:
                    # DALL-E often generates 1024x1024 or 512x512 images
                    if img.size in [(1024, 1024), (512, 512)]:
                        return 'chatgpt'
                    # Midjourney often has specific aspect ratios
                    if img.size[0] == img.size[1]:  # Perfect square
                        # Further check for Midjourney-specific metadata
                        if 'midjourney' in str(getattr(img, 'info', {})):
                            return 'midjourney'
            except Exception:
                pass
                
        return None
        
    def _get_creation_time(self, file_path):
        """Get file creation time in a standardized format
        
        Args:
            file_path: Path to the file
            
        Returns:
            str: Formatted creation time or None if unavailable
        """
        try:
            ctime = os.path.getctime(file_path)
            return datetime.datetime.fromtimestamp(ctime).strftime('%Y-%m-%d %H:%M:%S')
        except Exception as e:
            logging.debug(f"Could not get creation time for {file_path}: {e}")
            return None
    
    def _get_modification_time(self, file_path):
        """Get file modification time in a standardized format
        
        Args:
            file_path: Path to the file
            
        Returns:
            str: Formatted modification time or None if unavailable
        """
        try:
            mtime = os.path.getmtime(file_path)
            return datetime.datetime.fromtimestamp(mtime).strftime('%Y-%m-%d %H:%M:%S')
        except Exception as e:
            logging.debug(f"Could not get modification time for {file_path}: {e}")
            return None
    
    def _is_likely_screenshot(self, img, metadata):
        """Determine if an image is likely a screenshot based on properties
        
        Args:
            img: PIL Image object
            metadata: Existing metadata dictionary
            
        Returns:
            bool: True if likely a screenshot, False otherwise
        """
        # Common screenshot dimensions
        common_resolutions = [
            (1920, 1080), (2560, 1440), (3840, 2160),  # Common desktop resolutions
            (1280, 720), (1366, 768), (1440, 900), (1536, 864),
            (1024, 768), (1280, 800), (1680, 1050), (2560, 1600)
        ]
        
        # Check if dimensions match common screen resolutions
        if hasattr(img, 'size'):
            if img.size in common_resolutions or (img.size[1], img.size[0]) in common_resolutions:
                return True
                
            # Check if filename contains screenshot indicators
            if 'screenshot' in metadata['filename'].lower() or 'screen' in metadata['filename'].lower():
                return True
                
            # Check if PNG (common screenshot format) with screen-like dimensions
            if metadata['extension'] == '.png' and img.mode == 'RGB':
                # Most screenshots have specific aspect ratios (16:9, 16:10, 4:3)
                aspect = img.size[0] / img.size[1] if img.size[1] > 0 else 0
                if abs(aspect - 1.78) < 0.1 or abs(aspect - 1.6) < 0.1 or abs(aspect - 1.33) < 0.1:
                    return True
        
        return False
    
    def _is_likely_document(self, img, metadata):
        """Determine if an image is likely a document scan based on properties
        
        Args:
            img: PIL Image object
            metadata: Existing metadata dictionary
            
        Returns:
            bool: True if likely a document scan, False otherwise
        """
        # Common document indicators in filename
        doc_indicators = ['scan', 'doc', 'document', 'receipt', 'invoice', 'form', 'contract']
        
        # Check filename for document indicators
        if any(indicator in metadata['filename'].lower() for indicator in doc_indicators):
            return True
            
        # Check if dimensions match common document sizes (A4, letter, etc.)
        if hasattr(img, 'size'):
            # Common document aspect ratios (portrait orientation)
            doc_aspects = [1.414, 1.294]  # A4 and US Letter aspect ratios
            aspect = img.size[1] / img.size[0] if img.size[0] > 0 else 0  # Portrait orientation
            
            if any(abs(aspect - doc_aspect) < 0.1 for doc_aspect in doc_aspects):
                return True
        
        return False
    
    def is_supported(self, file_path):
        """Check if the file is a supported image format
        
        Args:
            file_path: Path to the file
            
        Returns:
            bool: True if supported, False otherwise
        """
        extension = Path(file_path).suffix.lower()
        return extension in self.supported_formats
        
    def is_whatsapp_media(self, file_path):
        """Check if the file is a WhatsApp media file based on filename pattern
        
        Args:
            file_path: Path to the file
            
        Returns:
            bool: True if it's a WhatsApp media file, False otherwise
        """
        file_name = Path(file_path).name.lower()
        return 'whatsapp' in file_name or 'wa' in file_name
        
    def is_telegram_media(self, file_path):
        """Check if the file is a Telegram media file based on filename pattern
        
        Args:
            file_path: Path to the file
            
        Returns:
            bool: True if it's a Telegram media file, False otherwise
        """
        file_name = Path(file_path).name.lower()
        return 'telegram' in file_name or 'tg' in file_name
        
    def is_instagram_media(self, file_path):
        """Check if the file is an Instagram media file based on filename pattern
        
        Args:
            file_path: Path to the file
            
        Returns:
            bool: True if it's an Instagram media file, False otherwise
        """
        file_name = Path(file_path).name.lower()
        return 'instagram' in file_name or 'ig' in file_name
        
    def is_facebook_media(self, file_path):
        """Check if the file is a Facebook media file based on filename pattern
        
        Args:
            file_path: Path to the file
            
        Returns:
            bool: True if it's a Facebook media file, False otherwise
        """
        file_name = Path(file_path).name.lower()
        return 'facebook' in file_name or 'fb' in file_name
        
    def is_youtube_media(self, file_path):
        """Check if the file is a YouTube media file based on filename pattern
        
        Args:
            file_path: Path to the file
            
        Returns:
            bool: True if it's a YouTube media file, False otherwise
        """
        file_name = Path(file_path).name.lower()
        return 'youtube' in file_name or 'yt' in file_name